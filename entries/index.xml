<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Entries on Marco Paga</title><link>https://marco-paga.eu/entries/</link><description>Recent content in Entries on Marco Paga</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 12 Apr 2022 08:17:03 +0100</lastBuildDate><atom:link href="https://marco-paga.eu/entries/index.xml" rel="self" type="application/rss+xml"/><item><title>Gitops</title><link>https://marco-paga.eu/entries/gitops/</link><pubDate>Tue, 12 Apr 2022 08:17:03 +0100</pubDate><guid>https://marco-paga.eu/entries/gitops/</guid><description>Table of contents: &lt;nav id="TableOfContents"&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#was-ist-gitops"&gt;Was ist GitOps?&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#warum"&gt;Warum?&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#was-war-nochmal-infastructure-as-code"&gt;Was war nochmal Infastructure as Code?&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#gitops"&gt;GitOps&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#flux-cd"&gt;Flux CD&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#flux-version-2"&gt;Flux Version 2&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#komponenten"&gt;Komponenten&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#konzepte"&gt;Konzepte&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#hello-world"&gt;„Hello, World!“&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#fazit-und-ausblick"&gt;Fazit und Ausblick&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
&lt;/nav&gt;
&lt;h2 id="was-ist-gitops"&gt;Was ist GitOps?&lt;/h2&gt;
&lt;p&gt;GitOps betrachtet den Auslieferungsprozess von Software auf den verschiedenen Stages von einer Entwicklungsumgebung bis hin zu einer produktiven Umgebung. Wie der Name schon vermuten lässt, wird git als Versionskontrollsystem verwendet und bildet damit die revisionssichere Historie ab. Alle Änderungen werden über diesen nachvollziehbaren Weg in eine Umgebung gebracht. Weiter gedacht wird die Umgebung an sich genau so erstellt und verwaltet.&lt;/p&gt;</description></item><item><title>Tekton Triggers CEL</title><link>https://marco-paga.eu/entries/tekton-triggers-cel/</link><pubDate>Sun, 27 Feb 2022 14:49:03 +0100</pubDate><guid>https://marco-paga.eu/entries/tekton-triggers-cel/</guid><description>&lt;p&gt;&lt;em&gt;or how to convert a git ref to a branch name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tektoncd/triggers"&gt;Tekton Triggers&lt;/a&gt; is a Tekton project which allows to receive webhooks and react appropriately to those. You can follow along &lt;a href="https://blog.codecentric.de/en/2022/03/tekton-triggers-in-practice/"&gt;my article on the codecentric blog&lt;/a&gt; to see what is possible.&lt;/p&gt;
&lt;p&gt;Tekton triggers includes a conecpt which is called &lt;a href="https://github.com/tektoncd/triggers/blob/main/docs/interceptors.md"&gt;Interceptors&lt;/a&gt; that provide a way to implement cross cutting concerns.
To give you a quick example: If you integrate Github with Tekton you hopefully want to validate if &lt;strong&gt;your&lt;/strong&gt; project is calling the tekton installation since you don&amp;rsquo;t want anybody stumbling on your tekton installation to run pipelines. How hard can it be? Just have a look at the &lt;a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks"&gt;documentation&lt;/a&gt; and see that you need to exchange secrests and need to run HMAC on the encoded request. Long story short: Just integrate the &lt;a href="https://github.com/tektoncd/triggers/blob/main/docs/interceptors.md#github-interceptors"&gt;GitHub&lt;/a&gt; interceptor and you are done.&lt;/p&gt;</description></item><item><title>Github Actions test a full Tekton CI installation</title><link>https://marco-paga.eu/entries/github-actions-testen-tekton-ci/</link><pubDate>Tue, 15 Feb 2022 00:00:00 +0100</pubDate><guid>https://marco-paga.eu/entries/github-actions-testen-tekton-ci/</guid><description>Table of contents: &lt;nav id="TableOfContents"&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href="#tekton-cloud-native-cicd"&gt;Tekton Cloud Native CI/CD&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#a-boiled-down-ci-pipeline"&gt;A boiled down CI Pipeline&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#interacting-with-tekton"&gt;Interacting with tekton&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#github-actions"&gt;GitHub Actions&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#demo-project"&gt;Demo Project&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#the-testing"&gt;The Testing&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="#recap"&gt;Recap&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
&lt;/nav&gt;
&lt;p&gt;In software development, it is good practice to write tests for the productive code. We see the value in our daily work in many places when it comes to further developing the software.
But CI - systems, although they make the safety net possible for whole teams in the first place, are often far from the principle. Build and test configurations are all too often developed and used without a net and a double bottom.
This is where I would like to start and take the proven principle even further. The article describes the setup of a tested CI system using the example of Tekton with GitHub Actions.&lt;/p&gt;</description></item></channel></rss>